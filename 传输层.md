# 传输层
## 1.协议
### TCP
> 面向连接的 可靠的 有流量控制 拥塞控制 提供全双工通信 面向字节流(将应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块) 一对一

---

### UDP 
> 无连接 不可靠 无拥塞和流量控制 面向报文(不拆分且不合并，只添加UDP首部) 支持一对一，一对多，多对一，多对多通信


## 2.细谈TCP
 + 名词定义
    + 序号：对字节流进行编号。例如序号为301，则表示第一个字节的编号为301，若携带的长度是100字节，那么下一个报文的序号是401
    + 确认号：当A发送了序号为301且长度为100字节的报文段给B,则B下一个期望的报文段序号就是401了，这是B发送给A的确认报文段中的确认号就是401
    + 数据偏移：指数据部分离报文段起始处的偏移量，即首部长度
    + 确认ACK：当ACK=1则表示确认号字段有效，否则无效。另外，在建立连接之后所有报文段都必选将ACK置1
    + 同步SYN：在连接建立时，用来同步序号
    + 终止FIN：用来释放一个连接
    + 窗口：窗口值作为接收方让发送方设置其发送窗口的依据。主要是因为接收方的数据缓存控件是有限的
 - 三次握手
  + 服务端B处于listen状态
  + 客户端A发送了seq = x syn = 1 给服务端B
  + 服务端B发送ACK = 1 seq = y ack = x+1 syn = 1
  + 客户端A发送ACK = 1 seq = x+1 ack = y+1 syn = 1给服务端B
  + 建立连接了

 - 四次挥手
  + 客户端A请求关闭连接，fin = 1 ，seq = u
  + 服务端B接收到报文之后，发送ACK = 1 ack = u+1 seq = v；给客户端A,此时服务端B已经确认了，客户端A不可以给服务端B发送消息了，TCP处于半关闭状态
  + 服务端B不需要连接时就发送关闭连接报文给客户端A fin = 1 ACK = 1 ack = v+1 seq = w
  + 客户端A发送 ACK = 1 ack = w+1 seq = u + 1，此时状态处于TIME-WAIT状态，等待2ML后释放连接
  + 服务端B收到确认之后释放连接
  
### 四次挥手的原因：
+ 客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文
+ TIME_WAIT
客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：
 + 确保最后一个确认报文能够到达。如果B没收到A发送来的确认报文，那么就会重新发送连接释放请求报文，A等待一段时间就是为了处理这种情况的发生。
 + 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。
## 3.拥塞控制
+ TCP可靠传输
>TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段
  
+ TCP滑动窗口
>  接收方和发送方都会有一个窗口，接收方通过TCP报文段中的窗口字段告诉发送方自己的窗口大小，然后发送方根据这个值以及其他信息来设置自己的窗口大小。
假设发送窗口左部的字节已经发送了并且收到了确认，那么就将发送窗口右滑动一定距离，直到左边的第一个字节不是已发送并且确认状态。接收窗口类似，也是看左部字节是否发送并交付给主机了

- TCP流量控制
> 流量控制是为了控制发送方发送速率，保证接收方来得及接收。接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小

+ TCP拥塞控制
>发送方会维护一个拥塞窗口cwnd的状态变量（区别于发送窗口，主要是cwnd只是一个状态变量，实际决定发送方能发送多少数据的是取决于发送方窗口）四个算法
    + 慢开始：从cwnd=1开始，每次加倍增长,网络拥塞的可能性就更高；
    + 拥塞避免:，当大于等于慢开始门限(ssthresh)时，就进入拥塞避免，每个轮次只加一。当超时时，则将ssthresh= cwnd/2,再执行慢开始。
    + 快重传：当收到三个重复确认时，就可以知道下一个报文丢失了，即执行快重传
    + 快恢复：这个情况只是报文丢失而不是网络拥塞，则执行快恢复，将sstresh= cwnd/2,cwnd = sstreshb并进去拥塞避免了






